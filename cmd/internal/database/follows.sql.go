// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: follows.sql

package database

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const followUser = `-- name: FollowUser :exec
INSERT INTO follows (follower_id, followee_id)
VALUES ($1, $2)
ON CONFLICT DO NOTHING
`

type FollowUserParams struct {
	FollowerID uuid.UUID `json:"follower_id"`
	FolloweeID uuid.UUID `json:"followee_id"`
}

func (q *Queries) FollowUser(ctx context.Context, arg FollowUserParams) error {
	_, err := q.db.ExecContext(ctx, followUser, arg.FollowerID, arg.FolloweeID)
	return err
}

const getFeed = `-- name: GetFeed :many
SELECT c.id, c.created_at, c.updated_at, c.body, c.user_id, u.email as author_email
FROM chirps c
INNER JOIN users u ON c.user_id = u.id
WHERE EXISTS (
    SELECT 1
    FROM follows f
    WHERE f.follower_id = $1
      AND f.followee_id = c.user_id
)
ORDER BY c.created_at DESC
LIMIT $2 OFFSET $3
`

type GetFeedParams struct {
	FollowerID uuid.UUID `json:"follower_id"`
	Limit      int32     `json:"limit"`
	Offset     int32     `json:"offset"`
}

type GetFeedRow struct {
	ID          uuid.UUID `json:"id"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
	Body        string    `json:"body"`
	UserID      uuid.UUID `json:"user_id"`
	AuthorEmail string    `json:"author_email"`
}

func (q *Queries) GetFeed(ctx context.Context, arg GetFeedParams) ([]GetFeedRow, error) {
	rows, err := q.db.QueryContext(ctx, getFeed, arg.FollowerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFeedRow
	for rows.Next() {
		var i GetFeedRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Body,
			&i.UserID,
			&i.AuthorEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFollowers = `-- name: GetFollowers :many
SELECT 
    u.id, 
    u.email, 
    u.is_chirpy_red, 
    u.created_at, 
    f.created_at as followed_at,
    COUNT(*) OVER() as total_followers
FROM follows f
INNER JOIN users u ON f.follower_id = u.id
WHERE f.followee_id = $1
ORDER BY f.created_at DESC
`

type GetFollowersRow struct {
	ID             uuid.UUID `json:"id"`
	Email          string    `json:"email"`
	IsChirpyRed    bool      `json:"is_chirpy_red"`
	CreatedAt      time.Time `json:"created_at"`
	FollowedAt     time.Time `json:"followed_at"`
	TotalFollowers int64     `json:"total_followers"`
}

func (q *Queries) GetFollowers(ctx context.Context, followeeID uuid.UUID) ([]GetFollowersRow, error) {
	rows, err := q.db.QueryContext(ctx, getFollowers, followeeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFollowersRow
	for rows.Next() {
		var i GetFollowersRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.IsChirpyRed,
			&i.CreatedAt,
			&i.FollowedAt,
			&i.TotalFollowers,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFollowing = `-- name: GetFollowing :many
SELECT 
    u.id, 
    u.email, 
    u.is_chirpy_red, 
    u.created_at, 
    f.created_at as followed_at,
    COUNT(*) OVER() as total_following
FROM follows f
INNER JOIN users u ON f.followee_id = u.id
WHERE f.follower_id = $1
ORDER BY f.created_at DESC
`

type GetFollowingRow struct {
	ID             uuid.UUID `json:"id"`
	Email          string    `json:"email"`
	IsChirpyRed    bool      `json:"is_chirpy_red"`
	CreatedAt      time.Time `json:"created_at"`
	FollowedAt     time.Time `json:"followed_at"`
	TotalFollowing int64     `json:"total_following"`
}

func (q *Queries) GetFollowing(ctx context.Context, followerID uuid.UUID) ([]GetFollowingRow, error) {
	rows, err := q.db.QueryContext(ctx, getFollowing, followerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFollowingRow
	for rows.Next() {
		var i GetFollowingRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.IsChirpyRed,
			&i.CreatedAt,
			&i.FollowedAt,
			&i.TotalFollowing,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isFollowing = `-- name: IsFollowing :one
SELECT EXISTS(
    SELECT 1 FROM follows
    WHERE follower_id = $1 AND followee_id = $2
) as is_following
`

type IsFollowingParams struct {
	FollowerID uuid.UUID `json:"follower_id"`
	FolloweeID uuid.UUID `json:"followee_id"`
}

func (q *Queries) IsFollowing(ctx context.Context, arg IsFollowingParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, isFollowing, arg.FollowerID, arg.FolloweeID)
	var is_following bool
	err := row.Scan(&is_following)
	return is_following, err
}

const unfollowUser = `-- name: UnfollowUser :exec
DELETE FROM follows
WHERE follower_id = $1 AND followee_id = $2
`

type UnfollowUserParams struct {
	FollowerID uuid.UUID `json:"follower_id"`
	FolloweeID uuid.UUID `json:"followee_id"`
}

func (q *Queries) UnfollowUser(ctx context.Context, arg UnfollowUserParams) error {
	_, err := q.db.ExecContext(ctx, unfollowUser, arg.FollowerID, arg.FolloweeID)
	return err
}
